(defun memq2 (item x)
  (cond ((null x) nil)
        ((eq item (car x)) x)
        (t (memq item (cdr x)))))

;;; 2.53
(list 'a 'b 'c)
('a 'b 'c)

(list (list 'george))
(('george))

(cdr '((x1 x2) (y1 y2)))
(y1 y2)

(cadr '((x1 x2) (y1 y2)))
(y1 y2)

(consp (car '(a short list)))
nil

(memq2 'red '((red shoes) (blue socks)))
nil

(memq2 'red '(red shoes blue socks))
(red shoes blue socks)

;;; 2.54
(defun equal? (lst1 lst2)
  (cond
   ((and (symbolp lst1) (symbolp lst2)) (eq lst1 lst2))
   ((symbolp lst1) (symbolp lst2))
   ((symbolp lst2) (symbolp lst1))
   (t (and (equal? (car lst1) (car lst2))
           (equal? (cdr lst1) (cdr lst2))))))

(equal? 'a 'a)
(equal? 'a '())
(equal? '(a b) '(a b))
(equal? '(a b) '(a b c))
(equal? '(this is a test) '(this (is a) test))

;;; 2.55
;; ''abc === (quote (quote abc))


;;; 2.56
(defun variable? (x)
  (symbolp x))
(defun same-variable? (v1 v2)
  (and (variable? v1) (variable? v2) (eq v1 v2)))
(defun =number? (exp num)
  (and (numberp exp) (= exp num)))
(defun make-sum (a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (numberp a1) (numberp a2)) (+ a1 a2))
        (t (list '+ a1 a2))))
;; (defun make-sum (a1 a2)
;;   (list '+ a1 a2))
(defun make-product (m1 m2)
  (list '* m1 m2))
(defun make-product (m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (numberp m1) (numberp m2) (* m1 m2)))
        (t (list '* m1 m2))))
(defun sum? (x)
  (and (consp x) (eq (car x) '+)))
(defun addend (s)
  (cadr s))
(defun augend (s)
  (caddr s))
(defun product? (x)
  (and (consp x) (eq (car x) '*)))
(defun multiplier (p)
  (cadr p))
(defun multiplicand (p)
  (caddr p))
(defun make-exponentation (base exp)
  (cond ((=number? exp 0) 1)
        ((=number? exp 1) base)
        ((and (numberp base) (numberp exp)) (expt base exp))
        (t (list '** base exp))))
(defun exponentation? (x)
  (and (consp x) (eq (car x) '**)))
(defun base (x)
  (cadr x))
(defun exponent (x)
  (caddr x))
(defun deriv (exp var)
  (cond ((numberp exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        ((exponentation? exp)
         (make-product
          (make-product
           (exponent exp)
           (make-exponentation (base exp) (- (exponent exp) 1)))
          (deriv (base exp) var)))
        (t (error "unknown expression type -- DERIV" exp))))

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)

;;; 2.57
(defun make-sum (&rest nums)
  (append (list '+) nums))
;; (cddr (make-sum 1 2 3))
(defun augend (s)
  (let ((aug (cddr s)))
    (if (= (length aug) 1)
        (car aug)
      (append (list '+) aug))))
;; (augend (make-sum 1 2 3 4))
(defun make-product (&rest nums)
  (append (list '*) nums))
(defun multiplicand (p)
  (let ((mul (cddr p)))
    (if (= (length mul) 1)
        (car mul)
      (append (list '*) mul))))

(deriv '(+ x x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* x y (+ x 3)) 'x)

;;; 2.58
(defun make-sum (a1 a2)
  (list a1 '+ a2))
(defun sum? (x)
  (and (consp x) (eq (cadr x) '+)))
(defun addend (s)
  (car s))
(defun augend (s)
  (caddr s))
(defun make-product (a1 a2)
  (list a1 '* a2))
(defun product? (x)
  (and (consp x) (eq (cadr x) '*)))
(defun multiplier (p)
  (car p))
(defun multiplicand (p)
  (caddr p))

(deriv '(x + 3) 'x)
(deriv '(x * y) 'x)
(deriv '((x * y) * (x + 3)) 'x)

